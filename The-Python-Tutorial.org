* [[https://docs.python.org/3/tutorial/introduction.html][3. An Informal Introduction to Python — Python 3.6.5 documentation]]

** Numbers

整数自动被转换成浮点数：

#+begin_src python :results output
  print(3 / 4)
  print(1.0 * 1)
#+end_src

#+RESULTS:
: 0.75
: 1.0

~//~ 跟 ~/~ 类似但去掉小数部分：

#+begin_src python :results output
    print(8 / 5)
    print(8 // 5)
#+end_src

#+RESULTS:
: 1.6
: 1

指数运算用 ~**~

#+begin_src python :results output
  print(2 ** 10)
#+end_src

#+RESULTS:
: 1024

变量赋值用 ~=~

#+begin_src python :results output
two = 2
ten = 10
result = two ** ten
print("2 的 10 次方为", result)
#+end_src

#+RESULTS:
: 2 的 10 次方为 1024

混和了整数和浮点数的计算会先把整数转换成浮点数

#+begin_src python :results output
print(2 * 0.5)
#+end_src

#+RESULTS:
: 1.0

** Strings

单双引号都能表示

#+begin_src python :results output
  print("Hello, Python!")
  print('Hello, Python!')
#+end_src

#+RESULTS:
: Hello, Python!
: Hello, Python!

如有需要 Escape 引号的，用 ~\~

#+begin_src python :results output
print("single quote => '")
print('single quote => \'')
print('double quote => "')
print("double quote => \"")
#+end_src

#+RESULTS:
: single quote => '
: single quote => '
: double quote => "
: double quote => "

取消 ~\~ 的特殊含义，在前面加一个 ~r~

#+begin_src python :results output
print("Hello, World\n")
print(r"Hello, World\n")
#+end_src

#+RESULTS:
: Hello, World
:
: Hello, World\n

用 3 个引号表示超过一行的字符串

#+begin_src python :results output
    print("""\
    Usage: foo [OPTIONS]
         --version                 Show version
         --help                    Show help\
    """)
#+end_src

#+RESULTS:
: Usage: foo [OPTIONS]
:      --version                 Show version
:      --help                    Show help

用 ~+~ 串联字符串，用 ~*~ 重复字符串

#+begin_src python :results output
msg = "Hello, " + "World" + "!"
pad = '-' * 13
print(pad, msg, pad)
#+end_src

#+RESULTS:
: ------------- Hello, World! -------------

两个字符串摆到一起会自动相连

#+begin_src python :results output
print('Py' 'thon')
#+end_src

#+RESULTS:
: Python

上面这个特性是为了避免「longlines」

#+begin_src python :results output
  text = ('这是一个很长的段落，'
          '放到一个引号里写会导致'
          ' 「Long Line」。')
  print(text)
#+end_src

#+RESULTS:
: 这是一个很长的段落，放到一个引号里写会导致 「Long Line」。

获得字符串中的字符

#+begin_src python :results output
  word = "Hello"
  print(word[0])
  print(word[1])
  print(word[2])
  print(word[3])
  print(word[4])
#+end_src

#+RESULTS:
: H
: e
: l
: l
: o

索引从 0 开始，如果为负数则从结尾数起

#+begin_src python :results output
print('hello'[-1])
print('hello'[-5])
#+end_src

#+RESULTS:
: o
: h

对于长度为 ~N~ 的字符串，用 [0, N-1] 或者 [-1, -N] 索引。

~substring~ 在 Python 中叫做 Slicing 「切片？」

#+begin_src python :session :results output
  greeting = 'Hello, World!'
  print(greeting[0:5])
  print(greeting[7:-1])
  print()
  print(greeting[:5])
  print(greeting[7:])
#+end_src

#+RESULTS:
: Hello
: World
:
: Hello
: World!

写法是 [beg:end]，区间为 [beg, end)，下图有助于理解

#+begin_example
   +---+---+---+---+---+
   | H | E | L | L | O |
   +---+---+---+---+---+
   0   1   2   3   4   5
  -5  -4  -3  -2  -1
#+end_example

Python 的 String 一经生成就不能改动。

获得字符串的长度，用 ~len~

#+begin_src python :session
greeting = "Hello, World"
len(greeting)
#+end_src

#+RESULTS:
: 12

*** TODO String - See also

1. String 作为 Sequence 的一种
2. String 常用方法
3. 格式化字符串
4. printf

** Lists

列表、序列或数组

#+begin_src python :session :results value pp
  numbers = [1, 2, 3, 4, 5]
  numbers
#+end_src

#+RESULTS:
: [1, 2, 3, 4, 5]

跟 String 一样，List 也属于 Sequence 类型，因此也能「切片」

#+begin_src python :session :results output
  four_numbers = [1, 2, 3, 4]
  two_numbers = four_numbers[1:3]
  print("four_numbers = ", four_numbers)
  print("two_numbers = ", two_numbers)

  two_numbers[0] *= 100
  four_numbers[1] *= 200
  print("four_numbers = ", four_numbers)
  print("two_numbers = ", two_numbers)
#+end_src

#+RESULTS:
: four_numbers =  [1, 2, 3, 4]
: two_numbers =  [2, 3]
: four_numbers =  [1, 400, 3, 4]
: two_numbers =  [200, 3]

上例可说明：

1. 不像 String，List 的值可以改
2. 「切片」返回的是一个完全新的 List，修改其中一个不会对另一个值产生影响，跟 ~seq-subseq~ 一样

TODO Shallow copy 是什么意思？Python List 切片和 Emacs 的 ~seq-copy~ 都用到了这个术语。

List 串联用 ~+~

#+begin_src python :session
  [1, 2] + [3, 4]
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 |

加一个新元素用 ~append~

#+begin_src python :session
  # 不行，没报错，但也不返回结果
  # [1, 2, 3].append(4)

  list = [1, 2]
  list.append(3)
  list.append(4)
  list
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 |

甚至直接给 Slice 赋值，达到同时修改多值的目的

#+begin_src python :session
  list = [1, 2, 3, 4, 5]
  list[2:4] = [300, 400]
  list
#+end_src

#+RESULTS:
| 1 | 2 | 300 | 400 | 5 |

清空 List

#+begin_src python :session
  list = [1, 2, 3]
  # 为什么不直接 list = []，还是纯粹为了举例？
  list[:] = []
  list
#+end_src

#+RESULTS:
: []

用 ~len~ 获得 List 的长度

#+begin_src python :session
len([1, 2, 3])
#+end_src

#+RESULTS:
: 3

List 的嵌套

#+begin_src python :session :results output
numbers = [1, 2, 3]
characters = ['a', 'b', 'c']
lists = [numbers, characters]
print(lists[1])
print(lists[1][2])
#+end_src

#+RESULTS:
: ['a', 'b', 'c']
: c

** 第一步

生成 Fibonacci 序列 1, 1, 2, 3, 5, 8, ...

#+begin_src python :session :results output
  a, b = 0, 1
  while b < 10:
      print(b)
      a, b = b, a+b
#+end_src

#+RESULTS:
: 1
: 1
: 2
: 3
: 5
: 8

Python 中同时给多个变量赋值的计算顺序跟 ~cl-psetq~ 一样：

- 从左往右先计算完所以的值，最后在赋值

利用它，可以很容易地交换两个变量的值

#+begin_src python :session
  x = 1
  y = 2
  x, y = y, x
  [x, y]
#+end_src

#+RESULTS:
| 2 | 1 |

#+begin_src emacs-lisp
  (let ((x 1) (y 2))
    (cl-psetq x y
              y x)
    (list x y))
#+end_src

#+RESULTS:
| 2 | 1 |

Python 跟 C 一样，0 为假，其余均为真。

Python 对缩进有明确要求，这个别的语言不同。

~print~ 的参数 ~end~ 预设是一个空格，可以像这样修改它

#+begin_src python :results output
  numbers = [1, 2, 3, 4, 5]
  i = 0
  while i < len(numbers):
      print(numbers[i], end=',')
      i += 1
#+end_src

#+RESULTS:
: 1,2,3,4,5,

* [[https://docs.python.org/3/tutorial/controlflow.html][4. More Control Flow Tools — Python 3.6.5 documentation]]

** ~if~

if ... elif ... else

#+begin_src python :session :var s=(read-string "Number: ") :results output
  x = int(s)
  if x < 0:
      x = 0
      print('Negative changed to zero')
  elif x == 0:
      print('Zero')
  elif x == 1:
      print('Single')
  else:
      print('More')
#+end_src

#+RESULTS:
: More

** ~for~

#+begin_src python :session :results output
  strings = ['one', 'two', 'three']
  for x in strings:
      print(x, len(x))
#+end_src

#+RESULTS:
: one 3
: two 3
: three 5

修改 List，这会造成死循环：

#+begin_src python
  ints = [1, 2, 3]
  for x in ints:
    if x == 2:
      ints.insert(0, 100)
  return(ints)
#+end_src

可以为 for 专门先拷贝一份 List

#+begin_src python :session :results output
  ints = [1, 2, 3]
  for x in ints[:]:
    if x == 2:
      ints.insert(0, 200)
  print(ints)
#+end_src

#+RESULTS:
: [200, 1, 2, 3]

** ~range()~

#+begin_src python :session :results output
  for i in range(5):
    print(i)
#+end_src

#+RESULTS:
: 0
: 1
: 2
: 3
: 4

#+begin_src python :session :results output
  for i in range(3, 5):
    print(i)
#+end_src

#+RESULTS:
: 3
: 4

用索引遍历一个 List

#+begin_src python :session :results output
  numbers = ['one', 'two', 'three']
  for i in range(len(numbers)):
      print(numbers[i])
#+end_src

#+RESULTS:
: one
: two
: three

range() 的返回值是 iterable 的，可以被 for 和 list 这样的 iterator 理解

#+begin_src python :session
list(range(5))
#+end_src

#+RESULTS:
| 0 | 1 | 2 | 3 | 4 |

** ~break~, ~continue~ and ~else~

for ... else

#+begin_src python :session :results output
  for n in range(2, 10):
      for x in range(2, n):
          if n % x == 0:
              print(n, 'equals', x, '*', n//x)
              break
      else:
          print(n, 'is a prime number')    
#+end_src

#+RESULTS:
: 2 is a prime number
: 3 is a prime number
: 4 equals 2 * 2
: 5 is a prime number
: 6 equals 2 * 3
: 7 is a prime number
: 8 equals 2 * 4
: 9 equals 3 * 3

for ... continue

#+begin_src python :session :results output
  for num in range(2, 10):
      if num % 2 == 0:
          print('Found an even number', num)
          continue
      print("Found a number", num)
#+end_src

#+RESULTS:
: Found an even number 2
: Found a number 3
: Found an even number 4
: Found a number 5
: Found an even number 6
: Found a number 7
: Found an even number 8
: Found a number 9

** ~pass~

什么都不做，占位

#+begin_src python :session
  while True:
      pass
#+end_src

#+begin_src python :session
  def foo(arg):
      pass                            # TODO
#+end_src

** Defining Functions

定义函数：

- Name
- Arguments
- Docstring
- Return Value

#+begin_src python :session :results output
  def fib(n):
      """Print a Fibonacci series up to n."""
      a, b = 0, 1
      while b < n:
          print(a, end= ' ')
          a, b = b, a + b
      print()

  fib(100)
#+end_src

#+RESULTS:
: 0 1 1 2 3 5 8 13 21 34 55

#+begin_src python :session
  def fib2(n):
      result = []
      a, b = 0, 1
      while b < n:
          result.append(a)
          a, b = b, a + b
      return result

  fib2(10)
#+end_src

#+RESULTS:
| 0 | 1 | 1 | 2 | 3 | 5 |

** 参数表的定义和调用

设置参数预设值，会使之变成可选参数

#+begin_src python :results output
  def hello(name="World"):
    return "Hello, " + name + "!"
  print(hello())
  print(hello("Python"))
#+end_src

#+RESULTS:
: Hello, World!
: Hello, Python!

注意这个预设值只会求一次，有些类似

#+begin_src emacs-lisp :lexical t
  ;; -*- lexical-binding: t; -*-
  (let ((index 0) list)
    (defun foo ()
      (push (cl-incf index) list)
      list))

  (list (foo) (foo) (foo))
#+end_src

#+RESULTS:
| 1 |   |   |
| 2 | 1 |   |
| 3 | 2 | 1 |

#+begin_src python :session :results output
  def f(a, L=[]):
      L.append(a)
      return L

  # print([f(1), f(2), f(3)])
  print(f(1))
  print(f(2))
  print(f(3))
#+end_src

#+RESULTS:
: [1]
: [1, 2]
: [1, 2, 3]

函数调用者可以用关键词输入参数。

#+begin_src python :session
  def my_sum(*args, initial=0):
      return initial + sum(args)

  my_sum(1, 2, 3)
#+end_src

#+RESULTS:
: 6

#+begin_src python :session
  def concat(*args, sep="/"):
      return "/" + sep.join(args)

  concat("path", "to", "python")
#+end_src

#+RESULTS:
: /path/to/python

依照参数表的要求解压数据

#+begin_src python :session :results output
args = [1, 3]

print(list(range(args[0], args[1])))

print(list(range(*args)))
#+end_src

#+RESULTS:
: [1, 2]
: [1, 2]

** Lambda

#+begin_src python :session
add1 = lambda x: x + 1
add1(100)
#+end_src

#+RESULTS:
: 101

#+begin_src python :session
  pairs = [(1, "one"), (2, "two"), (3, "three"), (4, "four")]
  pairs.sort(key=lambda pair: pair[1])
  pairs
#+end_src

#+RESULTS:
| 4 | four  |
| 1 | one   |
| 3 | three |
| 2 | two   |

** Functions' Docstring

Docstring 的习俗，跟 Emacs 类似。

#+begin_src python :session
  def hello():
      """Print "Hello, World!\n".

      That is it.
      """
      print("Hello, World!")
#+end_src

用 ~__doc__~ 从获得 Docstring

#+begin_src python :session :results value pp
  hello.__doc__
#+end_src

#+RESULTS:
: 'Print "Hello, World!\n".\n\n    That is it.\n    '

** 编码风格 - PEP 8
